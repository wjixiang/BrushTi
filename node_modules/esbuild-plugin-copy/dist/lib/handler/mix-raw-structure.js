"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeCopyHandler = void 0;
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const chalk_1 = __importDefault(require("chalk"));
const utils_1 = require("../utils");
function mergeCopyHandler(outDir, from, to, verbose = false, dryRun = false) {
    // absolute file path for each pair's from
    const sourcePath = path_1.default.resolve(from);
    const parsedFromPath = path_1.default.parse(from);
    const parsedToPath = path_1.default.parse(to);
    // if we specified file name in to path, we use its basename
    // or, we make the from path base as default
    const distBaseName = parsedToPath.ext.length
        ? parsedToPath.base
        : parsedFromPath.base;
    // if user specified file name in `to` path:
    // case: ./file.ext, the parsed.dir will be '.' we need to use empty dist dir: ''
    // case: ./dir/file.ext, the parsed.dir will be './dir' and we need to use './dir'
    const distDir = parsedToPath.dir === '.' ? '' : parsedToPath.dir;
    const distPath = path_1.default.resolve(outDir, distDir, distBaseName);
    !dryRun && fs_extra_1.default.ensureDirSync(path_1.default.dirname(distPath));
    !dryRun && fs_extra_1.default.copyFileSync(sourcePath, distPath);
    (0, utils_1.verboseLog)(`${dryRun ? chalk_1.default.white('[DryRun] ') : ''}File copied: ${chalk_1.default.white(sourcePath)} -> ${chalk_1.default.white(distPath)}`, verbose);
}
exports.mergeCopyHandler = mergeCopyHandler;
