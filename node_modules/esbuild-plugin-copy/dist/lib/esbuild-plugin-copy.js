"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.copy = void 0;
const path_1 = __importDefault(require("path"));
const chalk_1 = __importDefault(require("chalk"));
const globby_1 = __importDefault(require("globby"));
const keep_raw_structure_1 = require("./handler/keep-raw-structure");
const mix_raw_structure_1 = require("./handler/mix-raw-structure");
const utils_1 = require("./utils");
const copy = (options = {}) => {
    const { assets = [], copyOnStart = false, globbyOptions = {}, verbose = false, once = false, keepStructure: globalKeepStructure = false, resolveFrom = 'out', dryRun = false, } = options;
    const formattedAssets = (0, utils_1.formatAssets)(assets);
    const applyHook = copyOnStart ? 'onStart' : 'onEnd';
    return {
        name: 'plugin:copy',
        setup(build) {
            build[applyHook](async () => {
                var _a;
                if (once && process.env[utils_1.PLUGIN_EXECUTED_FLAG] === 'true') {
                    (0, utils_1.verboseLog)(`Copy plugin skipped as option ${chalk_1.default.white('once')} set to true`, verbose);
                    return;
                }
                if (!formattedAssets.length) {
                    return;
                }
                let outDirResolve;
                if (resolveFrom === 'cwd') {
                    outDirResolve = process.cwd();
                }
                else if (resolveFrom === 'out') {
                    const outDir = (_a = build.initialOptions.outdir) !== null && _a !== void 0 ? _a : path_1.default.dirname(build.initialOptions.outfile);
                    if (!outDir) {
                        (0, utils_1.verboseLog)(chalk_1.default.red(`You should provide valid ${chalk_1.default.white('outdir')} or ${chalk_1.default.white('outfile')} for assets copy. received outdir:${build.initialOptions.outdir}, received outfile:${build.initialOptions.outfile}`), verbose);
                        return;
                    }
                    outDirResolve = outDir;
                }
                else {
                    outDirResolve = resolveFrom;
                }
                (0, utils_1.verboseLog)(`Resolve assert pair to path from: ${path_1.default.resolve(outDirResolve)}`, verbose);
                for (const { from, to, keepStructure: pairKeepStructure, } of formattedAssets) {
                    const pathsCopyFrom = await (0, globby_1.default)(from, {
                        expandDirectories: false,
                        onlyFiles: true,
                        ...globbyOptions,
                    });
                    const keep = globalKeepStructure || pairKeepStructure;
                    (0, utils_1.verboseLog)(`Use ${chalk_1.default.white(keep ? 'Keep-Structure' : 'Merge-Structure')} for current assets pair.`, verbose, true);
                    const deduplicatedPaths = [...new Set(pathsCopyFrom)];
                    if (!deduplicatedPaths.length) {
                        (0, utils_1.verboseLog)(`No files matched using current glob pattern: ${chalk_1.default.white(from)}, maybe you need to configure globby by ${chalk_1.default.white('options.globbyOptions')}?`, verbose);
                    }
                    for (const fromPath of deduplicatedPaths) {
                        to.forEach((toPath) => {
                            keep
                                ? (0, keep_raw_structure_1.keepStructureCopyHandler)(outDirResolve, from, fromPath, toPath, verbose, dryRun)
                                : (0, mix_raw_structure_1.mergeCopyHandler)(outDirResolve, fromPath, toPath, verbose, dryRun);
                        });
                    }
                    process.env[utils_1.PLUGIN_EXECUTED_FLAG] = 'true';
                }
            });
        },
    };
};
exports.copy = copy;
